## 重排重绘与分层



#### 触发分层

1. 获取DOM并将其分割为多个层
2. 将每个层独立的绘制进位图中
3. 将层作为文理上传至GPU
4. 复合多个层来生成最终的屏幕图像



1. DOM子树渲染层（RenderLayer）=> RenderObject => GraphicsContext（根元素、position、transform、半透明、css滤镜、Canvas2D、video、溢出）
2. Compositor => 渲染层子树的图形层（GraphicsLayer）=> RenderLayer => renderObject

Compositor将所有的拥有Compositor layer进行合成，合成过程GPU进行参与。合成完毕就能够将文理映射到一个网络几何上---在视频游戏或者CAD程序中，这种技术用来给框架式的3D模型添加“皮肤”。Chrome采用纹理把页面中的内容分块给GPU。纹理能够以很低的代价映射到不同的位置，而且还能够以很低的代价通过应用到一个非常简单的矩形网格中进行变形。这就是3D css的原理

> CSS3D透视变换、video、webGL、transform动画、加速css滤镜、叠加在已经触发合成层





#### 重排与重绘

##### 网页生成的时候，至少会渲染一次。用户访问的过程中还会不断重新渲染。以下三种情况都会导致网页重新渲染

1. 修改DOM
2. 修改样式表
3. 用户事件

> 重新渲染，就需要重新生成布局和重新绘制。前者叫`重排`（reflow），后者叫`重绘`（repaint）。需要注意的是`重绘`不一定需要`重排`，如果改变某个网页元素的颜色就只会触发`重绘`，不会触发`重排`。因为布局没有改变。但是`重排`必然到之后`重绘`，比如改变一个网页元素的位置，就会同时触发`重排`和`重绘`，因为布局改变了



##### 如何开发不会导致重排

1. 样式表越简单，重排和重绘就越快
2. 重排混合重绘的DOM元素层级越高，成本就越高。
3. table元素的重排和重绘的成本要高于div元素
4. 尽量不要把读操作和写操作放在一个语句里面。
5. 统一改变样式。
6. 缓存重排结果
7. 离线DOM Fragment / clone
8. 虚拟DOM React
9. 必要的时候`display: none`不可见元素不影响重排重绘，`visibility`对重排影响 不影响重绘

